#save functions as we go along here
#latest function is miss_summary and its complete except it doesnt show missing rate by sector

#this function gives you a summary of the datasets missing data, missing by firm and by variable, this was improved
#it gives a missing rate by sector which may be important for only one justification and so in future functions can be removed
```{r}
eda_summary = function(df){
  
  na_features =  as.data.frame(colSums(is.na.data.frame(df)*1))

  na_firms = cbind(df$Ticker, df$Time, df$Sector,as.data.frame(rowSums(is.na.data.frame(df)*1)))

  na_bysector = cbind(aggregate(na_firms[,4],by=list(Category=na_firms[,3]), FUN=sum), table(df$Sector))
  
  na_bysector = cbind(aggregate(na_firms[,4],by=list(Category=na_firms[,3]), FUN=sum), table(df$Sector),round((na_bysector[,2]/na_bysector[,4]),2))
  
  summ= list(na_features, na_firms, na_bysector)
  
  return(summ)#, na_firms, na_bysector)
  
}
```

#this function builds on miss f by returning and cleaning up and gives an overall sunarry of everything essentially, firm and var miss no and %
```{r}
miss_summary = function(df){
  
  #eda sunnary function
  eda_summary = function(df){
  na_features =  as.data.frame(colSums(is.na.data.frame(df)*1))
  na_firms = cbind(df$Ticker, df$Time, df$Sector,as.data.frame(rowSums(is.na.data.frame(df)*1)))
  na_bysector = cbind(aggregate(na_firms[,4],by=list(Category=na_firms[,3]), FUN=sum), table(df$Sector))
  na_bysector = cbind(aggregate(na_firms[,4],by=list(Category=na_firms[,3]), FUN=sum), table(df$Sector),round((na_bysector[,2]/na_bysector[,4]),2))
  summ= list(na_features, na_firms, na_bysector)
  return(summ)#, na_firms, na_bysector)
}

#second function begins here, shows missing percentage by firm, and miss firm
  x = eda_summary(df)
  
  library(data.table)
  miss_firm= setDT(as.data.frame(x[[2]][,4]))[, as.list(colSums(.SD)), by = gl(ceiling((length(df$Ticker))/40), 40, (length(df$Ticker)))]
  
  miss_firm = cbind(unique(df$Ticker), miss_firm[,2])
  
  miss_firm = cbind(miss_firm, (miss_firm[,2]/((length(df))*40))*100)
  
  colnames(miss_firm) = c("Ticker", "Miss no", "Miss%")
  
#third function begins here shows miss var 
  
  pMiss <- function(x){sum(is.na(x))/length(x)*100}
  miss_var= as.data.frame(apply(df,2,pMiss))
  miss_var = cbind(x[[1]], miss_var)
  colnames(miss_var) = c("Miss no", "Miss%") 
  
  #list
  l= (list(miss_firm, miss_var))
  names(l) = c("by firm", "by var")
  
  #return call
  return(l)
    
}
```

#this function gives summary stats
```{r}
sum_stats= function(df){
  
stats =as.data.frame(t( sapply(df, function(x) c( "Stand dev" = sd(x, na.rm = T), 
                         "Mean"= mean(x,na.rm=TRUE),
                         "n" = length(x),
                         "Median" = median(x,na.rm = T),
                         "CoeffofVariation" = sd(x, na.rm =T)/mean(x,na.rm=TRUE),
                         "Minimum" = min(x, na.rm = T),
                         "Maximun" = max(x,na.rm = T),
                         "Upper Quantile" = quantile(x,1, na.rm = T),
                         "LowerQuartile" = quantile(x,0, na.rm = T)
                    )
)))
return(stats)
}
```

#function that gives you missing by sector
```{r}
na_bysector = function(df){
  
  na_firms6k = cbind(df$Ticker,df$Time, df$Sector,as.data.frame(rowSums(is.na.data.frame(df)*1)))
  
  no6kbysector = cbind(aggregate(na_firms6k$`rowSums(is.na.data.frame(df) * 1)`,by=list(Category=na_firms6k$`df$Sector`), FUN=sum), table(df$Sector))

  x = as.data.frame(cbind(no6kbysector$Category, round((no6kbysector$x/no6kbysector$Freq),2)))
  
  colnames(x)= c("Sector", paste("Missing",deparse(substitute(df)),"%"))
  
return(x)
}
```


#function that does first differencing and tells us what percentage is stationery from the imp2 dataset required
```{r}
differencing = function(tlag){

  library(tseries)
  split_data = split(imp2, imp2$Ticker)

split_differenced = list()
for (i in 1:127) {
  split_differenced[[i]]=  as.data.frame(lapply(split_data[[i]], diff, lag= tlag))
  split_differenced[[i]][,2]= 1:(40-tlag)
}

#test to see if the data is now stationary 
ptd = matrix(0, nrow = 127, ncol = 124)
for (i in 1:127){
  for (j in 3:124){
    y = adf.test(as.data.frame(split_differenced[i])[,j])
    ptd[i,j]= y$p.value
  }
}

x = sum((ptd< 0.05) ==1, na.rm = T)/ length(ptd)
table(ptd< 0.05)

return(x)
}
```

 
 