#this file runs the random forest codes and stores the results into a list
#for more info on building it chec the file rf h20 prelim and results from sw rf
#this is for sliding window not expanding window
```{r}
load("~/Documents/Thesis/Thesis stuff/Thesis R/train and test data.RData")
#h2o.shutdown()
library(h2o)
h2o.init(min_mem_size='10G', max_mem_size='20G')

#seed already in function

train = train[-c(2,3)]
htrain = as.h2o(train)
independent_var = names(train)[2:122]
dependent_var = names(train)[1]
t=127 #const

hyperparams = list(mtries= c(10, 25, 50, 75),
          max_depth = c(5, 10, 20), #max depth of tree
          ntrees = c(50, 100, 200),
          min_rows = c(1, 5, 10)) #number of trees
```


```{r}
rf_sliding_window = function(qts){

ntr = qts
nts = qts
  
total_qts = 40 - ntr - nts
win =t*qts #training window size same as testing size
shift = t*2 #arbitrary 2 to make the strides manageable
y= ((total_qts-ntr-nts)/2)+1
print(y)
x=1
model_list = list()

for (i in 1:y) {

model = h2o.grid(
    algorithm = "randomForest",
    x = independent_var,
    y = dependent_var, 
    training_frame = htrain[(x):(x-1+win),],
    validation_frame= htrain[(x+win):(x-1+win+win),],
    hyper_params = hyperparams,
    seed = 786,
    nfolds= 0)

model_list[i] = model

x=x+shift
print(i)
}

best_model_list = list()
for (j in 1:y) {
    best_model_list[j]= h2o.getModel(model_list[[j]]@model_ids[[1]])
}

results = data.frame(NULL)

for (i in 1:length(best_model_list)) {
#params etc
a= best_model_list[[i]]@model[["model_summary"]]

#validation misclassification error
b= best_model_list[[i]]@model[["validation_metrics"]]@metrics[["cm"]][["table"]][["Error"]][5]

c = best_model_list[[i]]@parameters[["mtries"]]
d = cbind.data.frame(a,b,c)

results = rbind(results,d)
}
return_list = list(final_result = results, best_models = best_model_list, grids = model_list)
return(return_list)
}

```

```{r}
tr4 = rf_sliding_window(4)
tr6 = rf_sliding_window(6)
tr8 = rf_sliding_window(8)
tr10 = rf_sliding_window(10)
save.image(file='New_rf_runs_eq_qt.RData') 
```

#for testing start here
```{r}
load("~/Documents/Thesis/Thesis stuff/Thesis R/train and test data.RData")
library(h2o)
try(h2o.shutdown(prompt= FALSE)) 
h2o.init(min_mem_size='10G', max_mem_size='20G')
```

```{r}
swresults = list(tr4,tr6,tr8,tr10)
swmeanresults = data.frame(NULL)

for (i in 1:length(swresults)) {

d= (colMeans(swresults[[i]]$final_result))
swmeanresults = rbind.data.frame(swmeanresults,d)
}

colnames(swmeanresults) = names(swresults[[1]]$final_result)
colnames(swmeanresults)[10] = "validation_error"
colnames(swmeanresults)[11] = "mtries"
```

```{r}
rf_test = function(ntest,ntrain,ntrees, max_depth, min_rows, mtries){
t=127 #const
full = rbind(train,test)
full = full[-c(2,3)]
independent_var = names(full)[2:122]
dependent_var = names(full)[1]

ntest = ntest
ntrain = ntrain
htrain = full[(((40-ntest-ntrain)*t)+1):((40-ntest)*t),]
htest = full[(((40-ntest)*t)+1):5080,]

htrain = as.h2o(htrain)
htest = as.h2o(htest)

model = h2o.randomForest(  
                        x = independent_var,
                        y = dependent_var,
                        training_frame = htrain,
                        nfolds = 0,
                        seed = 786,
                        max_depth = max_depth,
                        min_rows = min_rows,
                        ntrees = ntrees,
                        mtries = mtries
)
cm = as.data.frame(h2o.confusionMatrix(model, htest))
result = data.frame(NULL)
d = cbind.data.frame(ntrain,ntest, ntrees,max_depth, min_rows, mtries, cm[["Error"]][5])

result = rbind(result,d)

results = list(model = model, cm = cm, result =result)
return(results)
}
```

```{r}
test_results = list()

test_results = append(test_results,list(q4_min = rf_test(4,4,round(min(tr4$final_result$number_of_trees),0),round(min(tr4$final_result$max_depth),0),1,round(min(tr4$final_result$c),0))))


test_results = append(test_results,list(q4_avg = rf_test(4,4,round(mean(tr4$final_result$number_of_trees),0),round(mean(tr4$final_result$max_depth),0),1,round(mean(tr4$final_result$c),0))))


test_results = append(test_results,list(q4_max = rf_test(4,4,round(max(tr4$final_result$number_of_trees),0),round(max(tr4$final_result$max_depth),0),1,round(max(tr4$final_result$c),0))))


test_results = append(test_results,list(q6_min = rf_test(6,6,round(min(tr6$final_result$number_of_trees),0),round(min(tr6$final_result$max_depth),0),1,round(min(tr6$final_result$c),0))))


test_results = append(test_results,list(q6_avg = rf_test(6,6,round(mean(tr6$final_result$number_of_trees),0),round(mean(tr6$final_result$max_depth),0),1,round(mean(tr6$final_result$c),0))))


test_results = append(test_results,list(q6_max = rf_test(6,6,round(max(tr6$final_result$number_of_trees),0),round(max(tr6$final_result$max_depth),0),1,round(max(tr6$final_result$c),0))))


test_results = append(test_results,list(q8_min = rf_test(8,8,round(min(tr8$final_result$number_of_trees),0),round(min(tr8$final_result$max_depth),0),1,round(min(tr8$final_result$c),0))))

test_results = append(test_results,list(q8_avg = rf_test(8,8,round(mean(tr8$final_result$number_of_trees),0),round(mean(tr8$final_result$max_depth),0),1,round(mean(tr8$final_result$c),0))))


test_results = append(test_results,list(q8_max = rf_test(8,8,round(max(tr8$final_result$number_of_trees),0),round(max(tr8$final_result$max_depth),0),1,round(max(tr8$final_result$c),0))))

test_results = append(test_results,list(q10 = rf_test(10,10,round(max(tr10$final_result$number_of_trees),0),round(max(tr10$final_result$max_depth),0),1,round(max(tr10$final_result$c),0))))
```

```{r}
result_combined = data.frame(NULL)
for (i in test_results) {
  result_combined = rbind(result_combined,i$result)
}

save.image(file='New_rf_runs_eq_qt.RData')
```

```{r}
library(writexl)
write_xlsx(as.data.frame(result_combined), path  = 'eq_qts_test_results_combined.xlsx')
```



